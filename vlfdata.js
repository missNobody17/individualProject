const fs=require("fs"),path=require("path"),fetch=(...a)=>import("node-fetch").then((({default:t})=>t(...a))),months_len_day=[31,28,31,30,31,30,31,31,30,31,30,31],months=["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"],coord={jjy:{lat:37.372557,long:140.849007},jji:{lat:32.092247,long:130.829095},nwc:{lat:-21.816325,long:114.16546},npm:{lat:21.420382,long:158.153912},ptk:{lat:53.15,long:158.92}},getData=a=>{const t=path.join(__dirname,a);return fs.readFileSync(t,"utf8")},csvToArray=a=>a.slice(a.indexOf("\n")+1).split("\n"),average=a=>{let t=0;for(let e of a.flat(1/0))e&&(t+=e);return t/a.length||0},arraySubstract=(a,t)=>{const e=[];for(let o of a)e.push(o-t);return e},convertTime12to24=a=>{const[t,e]=a.split(" ");let[o,s,r]=t.split(":");return"12"===o&&(o="00"),"PM"===e&&(o=parseInt(o,10)+12),`${o}.${s}`},convertToInterval=a=>{const t=convertTime12to24(a);let e=Math.floor(t),o=Math.round(100*(t-e)),s=180*e+3*o;return s<0&&(s+=4320),[s,[e,o]]},getSunsetSunrise=async(a,t,e,o)=>{const s=[],r=[];if(o){const e=`https://api.sunrise-sunset.org/json?lat=${coord.ptk.lat}lng=${coord.ptk.long}&date=${t}-${a}-${o}`,l=await fetch(e),n=(await l.json()).results;Boolean(n.astronomical_twilight_begin)&&(s.push([convertToInterval(n.astronomical_twilight_end)[0],convertToInterval(n.astronomical_twilight_begin)[0],convertToInterval(n.nautical_twilight_end)[0],convertToInterval(n.nautical_twilight_begin)[0]]),r.push([convertToInterval(n.astronomical_twilight_end)[1],convertToInterval(n.astronomical_twilight_begin)[1],convertToInterval(n.nautical_twilight_end)[1],convertToInterval(n.nautical_twilight_begin)[1]]))}return[s,r]},removeDay=async(a,t,e,o,s)=>{const r=await getSunsetSunrise(t,e,0,s);return r[0][0][0]===r[0][0][1]?(a.splice(r[0][0][3],r[0][0][2]-r[0][0][3]),[a,[r[1][0][3],r[1][0][2]]]):(a.splice(r[0][0][1],r[0][0][0]-r[0][0][1]),[a,[r[1][0][1],r[1][0][0]]])},rawData=async(a,t,e,o,s,r,l,n)=>{const i=[],p=[],$=months[parseInt(a,10)],c=months_len_day[a],h=parseInt(t,10)%10,g=[];let d,f=0;if(l="undefined"===(n="undefined"===n?void 0:parseInt(n,10))?void 0:parseInt(l,10),r="undefined"===r?void 0:parseInt(r,10),Boolean(r)){if(r>0&&r<10)try{d=await getData(`./VLF-data/${t}/${$}/T0${r}${$}${h}A.kam`)}catch(a){console.log(a)}else try{d=await getData(`./VLF-data/${t}/${$}/T${r}${$}${h}A.kam`)}catch(a){console.log(a)}if(d)for(let a of csvToArray(d))void 0!==a&&Boolean(a.split(/\t/)[e])&&i.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&p.push(parseFloat(a.split(/\t/)[o]));if(f=months_len_day[a],"night"===s){const e=await removeDay(i,a,t,0,r),o=await removeDay(p,a,t,0,r);return[e[0],o[0],f,[parseFloat(String(e[1][0][0])+"."+String(e[1][0][1])),parseFloat(String(e[1][1][0])+"."+String(e[1][1][1]))]]}}else if(Boolean(l)&&Boolean(n)){for(let r=l;r<=n;r++){let l=[],n=[];if(r>0&&r<10)try{d=await getData(`./VLF-data/${t}/${$}/T0${r}${$}${h}A.kam`)}catch(a){console.log(a);break}else try{d=await getData(`./VLF-data/${t}/${$}/T${r}${$}${h}A.kam`)}catch(a){console.log(a);break}if(d){for(let a of csvToArray(d))void 0!==a&&Boolean(a.split(/\t/)[e])&&l.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&n.push(parseFloat(a.split(/\t/)[o]));if("night"===s){const e=await removeDay(l,a,t,0,r),o=await removeDay(n,a,t,0,r);g.push(e[0].length),i.push(...e[0]),p.push(...o[0])}else i.push(...l),p.push(...n)}}f=months_len_day[a]}else for(let r=1;r<c+1;r++){let l=[],n=[];if(r>0&&r<10)try{d=await getData(`./VLF-data/${t}/${$}/T0${r}${$}${h}A.kam`)}catch(a){console.log(a);break}else try{d=await getData(`./VLF-data/${t}/${$}/T${r}${$}${h}A.kam`)}catch(a){console.log(a);break}if(d){for(let a of csvToArray(d))void 0!==a&&Boolean(a.split(/\t/)[e])&&l.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&n.push(parseFloat(a.split(/\t/)[o]));if("night"===s){const e=await removeDay(l,a,t,0,r),o=await removeDay(n,a,t,0,r);g.push(e[0].length),i.push(...e[0]),p.push(...o[0])}else i.push(...l),p.push(...n)}f+=1}return[i,p,f,g]},averageData=async(a,t,e,o)=>{const s=[],r=[],l=months[parseInt(a,10)],n=months_len_day[a],i=parseInt(t,10)%10;let p;for(let a=1;a<n+1;a++){if(a>0&&a<10)try{p=await getData(`./VLF-data/${t}/${l}/T0${a}${l}${i}A.kam`)}catch(a){console.log(a);break}else try{p=await getData(`./VLF-data/${t}/${l}/T${a}${l}${i}A.kam`)}catch(a){console.log(a);break}if(p){let a=[],t=[];for(let s of csvToArray(p))void 0!==s&&Boolean(s.split(/\t/)[e])&&a.push(parseFloat(s.split(/\t/)[e])),void 0!==s&&Boolean(s.split(/\t/)[o])&&t.push(parseFloat(s.split(/\t/)[o]));s.push(average(a)),r.push(average(t))}}return[s,r]},avg=async(a,t,e,o,s,r,l)=>{const n=[],i=[],p=months[parseInt(a,10)],$=1!==a?months[parseInt(a,10)-1]:"DEC",c=1===a?t-1:void 0,h=months_len_day[a],g=1===a?months_len_day[12]:months_len_day[a-1],d=parseInt(t,10)%10;let f;if(s="undefined"===s?void 0:parseInt(s,10)){let a=[],r=[];for(let l=s-5;l<s+1;l++){if(l<1)try{f=Boolean(c)?await getData(`./VLF-data/${c}/${$}/T${g+l}${$}${parseInt(c,10)%10}A.kam`):await getData(`/VLF-data/${t}/${$}/T${g+l}${$}${d}A.kam`)}catch(a){console.log(a);break}else if(l>0&&l<10)try{f=await getData(`./VLF-data/${t}/${p}/T0${l}${p}${d}A.kam`)}catch(a){console.log(a);break}else try{f=await getData(`./VLF-data/${t}/${p}/T${l}${p}${d}A.kam`)}catch(a){console.log(a);break}if(f)for(let t of csvToArray(f))void 0!==t&&Boolean(t.split(/\t/)[e])&&a.push(parseFloat(t.split(/\t/)[e])),void 0!==t&&Boolean(t.split(/\t/)[o])&&r.push(parseFloat(t.split(/\t/)[o]))}n.push(average(a)),i.push(average(r))}else if(Boolean(r)&&Boolean(l))for(let a=r;a<=l;a++){let s=[],r=[];for(let l=a-5;l<a+1;l++){if(l<1)try{f=Boolean(c)?await getData(`./VLF-data/${c}/${$}/T${g+l}${$}${parseInt(c,10)%10}A.kam`):await getData(`/VLF-data/${t}/${$}/T${g+l}${$}${d}A.kam`)}catch(a){console.log(a);break}else if(l>0&&l<10)try{f=await getData(`./VLF-data/${t}/${p}/T0${l}${p}${d}A.kam`)}catch(a){console.log(a);break}else try{f=await getData(`./VLF-data/${t}/${p}/T${l}${p}${d}A.kam`)}catch(a){console.log(a);break}if(f)for(let a of csvToArray(f))void 0!==a&&Boolean(a.split(/\t/)[e])&&s.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&r.push(parseFloat(a.split(/\t/)[o]))}n.push(average(s)),i.push(average(r))}else for(let a=1;a<h+1;a++){let s=[],r=[];for(let l=a-5;l<a+1;l++){if(l<1)try{f=Boolean(c)?await getData(`./VLF-data/${c}/${$}/T${g+l}${$}${parseInt(c,10)%10}A.kam`):await getData(`/VLF-data/${t}/${$}/T${g+l}${$}${d}A.kam`)}catch(a){console.log(a);break}else if(l>0&&l<10)try{f=await getData(`./VLF-data/${t}/${p}/T0${l}${p}${d}A.kam`)}catch(a){console.log(a);break}else try{f=await getData(`./VLF-data/${t}/${p}/T${l}${p}${d}A.kam`)}catch(a){console.log(a);break}if(f)for(let a of csvToArray(f))void 0!==a&&Boolean(a.split(/\t/)[e])&&s.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&r.push(parseFloat(a.split(/\t/)[o]))}n.push(average(s)),i.push(average(r))}return[n,i]},difference=async(a,t,e,o,s,r,l,n)=>{const i=[],p=[],$=months[parseInt(a,10)],c=months_len_day[a],h=parseInt(t,10)%10;let g;r="undefined"===r?void 0:parseInt(r,10),l="undefined"===(n="undefined"===n?void 0:parseInt(n,10))?void 0:parseInt(l,10);const[d,f]=await avg(a,t,e,o,r,l,n);if(r){let l=[],n=[];if(r>0&&r<10)try{g=await getData(`./VLF-data/${t}/${$}/T0${r}${$}${h}A.kam`)}catch(a){console.log(a)}else try{g=await getData(`./VLF-data/${t}/${$}/T${r}${$}${h}A.kam`)}catch(a){console.log(a)}if(g){for(let a of csvToArray(g))void 0!==a&&Boolean(a.split(/\t/)[e])&&l.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&n.push(parseFloat(a.split(/\t/)[o]));i.push(...arraySubstract(l,d)),p.push(...arraySubstract(n,f))}if("night"===s){const e=await removeDay(i,a,t,0,r),o=await removeDay(p,a,t,0,r);return[e[0],o[0]]}}else if(Boolean(l)&&Boolean(n)){let r=0;for(let c=l;c<=n;c++){let l=[],n=[];if(c>0&&c<10)try{g=await getData(`./VLF-data/${t}/${$}/T0${c}${$}${h}A.kam`)}catch(a){console.log(a);break}else try{g=await getData(`./VLF-data/${t}/${$}/T${c}${$}${h}A.kam`)}catch(a){console.log(a);break}if(g){for(let a of csvToArray(g))void 0!==a&&Boolean(a.split(/\t/)[e])&&l.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&n.push(parseFloat(a.split(/\t/)[o]));if("night"===s){const e=await removeDay(l,a,t,0,c),o=await removeDay(n,a,t,0,c);i.push(...arraySubstract(e[0],d[r])),p.push(...arraySubstract(o[0],f[r]))}else i.push(...arraySubstract(l,d[r])),p.push(...arraySubstract(n,f[r]))}}}else for(let r=1;r<c+1;r++){let l=[],n=[];if(r>0&&r<10)try{g=await getData(`./VLF-data/${t}/${$}/T0${r}${$}${h}A.kam`)}catch(a){console.log(a);break}else try{g=await getData(`./VLF-data/${t}/${$}/T${r}${$}${h}A.kam`)}catch(a){console.log(a);break}if(g){for(let a of csvToArray(g))void 0!==a&&Boolean(a.split(/\t/)[e])&&l.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&n.push(parseFloat(a.split(/\t/)[o]));if("night"===s){const e=await removeDay(l,a,t,0,r),o=await removeDay(n,a,t,0,r);i.push(...arraySubstract(e[0],d[r])),p.push(...arraySubstract(o[0],f[r]))}else i.push(...arraySubstract(l,d[r])),p.push(...arraySubstract(n,f[r]))}}return[i,p]},weekBeforeAfter=async(a,t,e,o,s,r)=>{const l=[],n=[],i=[],p=months[parseInt(a,10)],$=1!==a?months[parseInt(a,10)-1]:"DEC",c=1===a?t-1:void 0,h=12!==a?months[parseInt(a,10)+1]:"JAN",g=12===a?t+1:void 0,d=months_len_day[a],f=1===a?months_len_day[12]:months_len_day[a-1],u=parseInt(t,10)%10;let v;if(r="undefined"===r?void 0:parseInt(r,10)){let y=[],m=[];for(let w=r-7;w<=r+7;w++){if(w<1)try{v=Boolean(c)?await getData(`./VLF-data/${c}/${$}/T${f+w}${$}${parseInt(c,10)%10}A.kam`):await getData(`/VLF-data/${t}/${$}/T${f+w}${$}${u}A.kam`)}catch(a){console.log(a);break}else if(w>0&&w<10)try{v=await getData(`./VLF-data/${t}/${p}/T0${w}${p}${u}A.kam`)}catch(a){console.log(a);break}else if(w>d)try{v=Boolean(g)?await getData(`./VLF-data/${g}/${h}/T0${w-d}${h}${parseInt(g,10)%10}A.kam`):await getData(`/VLF-data/${t}/${h}/T0${w-d}${h}${u}A.kam`)}catch(a){console.log(a);break}else try{v=await getData(`./VLF-data/${t}/${p}/T${w}${p}${u}A.kam`)}catch(a){console.log(a);break}if(v){y=[],m=[];for(let a of csvToArray(v))void 0!==a&&Boolean(a.split(/\t/)[e])&&y.push(parseFloat(a.split(/\t/)[e])),void 0!==a&&Boolean(a.split(/\t/)[o])&&m.push(parseFloat(a.split(/\t/)[o]));if("night"===s){let e=w>d?w-d:w<1?f+w:w;const o=await removeDay(y,a,t,0,e),s=await removeDay(m,a,t,0,e);l.push(...o[0]),n.push(...s[0]),i.push(o[0].length)}else l.push(...y),n.push(...m)}}}return[l,n,i]};module.exports={rawData,averageData,avg,difference,removeDay,weekBeforeAfter};